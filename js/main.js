// Generated by CoffeeScript 1.9.2
(function() {
  var BACKGROUND_COLOR, SPHERE_COUNT, SPHERE_DIFFUSE, SPHERE_MASS, SPHERE_RADIUS, SPHERE_SHININESS, SPHERE_SPECULAR, SPRING_STIFFNESS, TIMESTEP, analyser, animate, audioContext, binCount, camera, createSphere, freqByteData, hemi, i, length, levelBins, levelHistory, levelsCount, levelsData, light, load, renderer, scene, spheres, timeByteData, world;

  TIMESTEP = 1 / 60;

  SPHERE_COUNT = 64;

  SPHERE_DIFFUSE = 0xE7112B;

  SPHERE_SPECULAR = 0xFF8585;

  SPHERE_SHININESS = 50;

  SPHERE_RADIUS = 0.7;

  SPHERE_MASS = 1;

  SPRING_STIFFNESS = 40;

  BACKGROUND_COLOR = 0x333333;

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100);

  camera.position.z = 60;

  scene.add(camera);

  light = new THREE.AmbientLight(0x404040);

  scene.add(light);

  hemi = new THREE.HemisphereLight(0xFF8585, 0x000000, 0.5);

  scene.add(hemi);

  renderer = new THREE.WebGLRenderer({
    alpha: true
  });

  renderer.setSize(window.innerWidth, window.innerHeight);

  renderer.setClearColor(BACKGROUND_COLOR, 0);

  document.body.appendChild(renderer.domElement);

  world = new CANNON.World();

  world.gravity.set(0, 0, 0);

  world.broadphase = new CANNON.NaiveBroadphase();

  world.solver.iterations = 10;

  createSphere = function(x, y, z, i) {
    var body, geometry, material, mesh, shape;
    shape = new CANNON.Sphere(SPHERE_RADIUS);
    body = new CANNON.Body({
      mass: SPHERE_MASS
    });
    body.position.set(x, y, z);
    body.velocity.set(Math.random() * 5, Math.random() * 5, z);
    body.addShape(shape);
    world.addBody(body);
    body.preStep = function() {
      var distance, origin;
      origin = new CANNON.Vec3(x, y, z);
      origin.vsub(this.position, origin);
      distance = origin.norm();
      origin.normalize();
      origin.mult(SPRING_STIFFNESS * distance, this.force);
      shape.radius = 0.3 + Math.pow(levelsData[i], 1.2) * 5;
      shape.updateBoundingSphereRadius();
      body.updateBoundingRadius();
      material.color = new THREE.Color(SPHERE_DIFFUSE);
      material.color.multiply(new THREE.Color(Math.min(0xffffff, 0xffffff * (levelsData[i] + 0.3))));
      material.specular = new THREE.Color(SPHERE_SPECULAR);
      material.specular.multiply(new THREE.Color(Math.min(0xffffff, 0xffffff * (levelsData[i] + 0.3))));
      return mesh.scale.set(shape.radius, shape.radius, shape.radius);
    };
    geometry = new THREE.SphereGeometry(SPHERE_RADIUS, 32, 32);
    material = new THREE.MeshPhongMaterial({
      color: SPHERE_DIFFUSE,
      specular: SPHERE_SPECULAR,
      shininess: SPHERE_SHININESS,
      shading: THREE.SmoothShading
    });
    mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    return [mesh, body];
  };

  spheres = (function() {
    var k, ref, results;
    results = [];
    for (i = k = 0, ref = SPHERE_COUNT; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      results.push(createSphere((i * 2 - SPHERE_COUNT) * 0.7, Math.random() * 0.01, Math.random(), i));
    }
    return results;
  })();

  animate = function() {
    var body, j, k, l, len, m, mesh, ref, ref1, ref2, sum;
    analyser.getByteFrequencyData(freqByteData);
    analyser.getByteTimeDomainData(timeByteData);
    for (i = k = 0, ref = levelsCount; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      sum = 0;
      for (j = l = 0, ref1 = levelBins; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
        sum += freqByteData[(i * levelBins) + j];
      }
      levelsData[i] = sum / levelBins / 256;
      levelsData[i] *= 1 + Math.pow((i / levelsCount) * 1.4, 2);
    }
    world.step(TIMESTEP);
    for (m = 0, len = spheres.length; m < len; m++) {
      ref2 = spheres[m], mesh = ref2[0], body = ref2[1];
      mesh.position.copy(body.position);
      mesh.quaternion.copy(body.quaternion);
    }
    renderer.render(scene, camera);
    return requestAnimationFrame(animate);
  };

  levelsCount = SPHERE_COUNT;

  audioContext = new window.AudioContext();

  analyser = audioContext.createAnalyser();

  analyser.smoothingTimeConstant = 0.8;

  analyser.fftSize = 1024;

  analyser.connect(audioContext.destination);

  binCount = analyser.frequencyBinCount;

  levelsData = [];

  levelBins = Math.floor(binCount / levelsCount);

  freqByteData = new Uint8Array(binCount);

  timeByteData = new Uint8Array(binCount);

  length = 256;

  levelHistory = (function() {
    var k, results;
    results = [];
    for (i = k = 0; k < 256; i = ++k) {
      results.push(0);
    }
    return results;
  })();

  load = function(id, callback) {
    var req;
    req = new XMLHttpRequest();
    req.onload = function() {
      var audio, audioStream, info, source, video;
      info = JSON.parse(req.responseText).info;
      window.info = info;
      audioStream = info.formats.filter(function(f) {
        return !f.height;
      })[0];
      if (audioStream) {
        audio = document.getElementById("audio");
        audio.crossOrigin = "anonymous";
        audio.src = "http://crossorigin.me/" + audioStream.url;
        source = audioContext.createMediaElementSource(audio);
      } else {
        video = document.getElementById("video");
        video.crossOrigin = "anonymous";
        video.src = "http://crossorigin.me/" + info.url;
        source = audioContext.createMediaElementSource(video);
      }
      return source.connect(analyser);
    };
    req.open('GET', "https://youtube-dl.appspot.com/api/info?url=" + id + "&flatten=false", true);
    return req.send();
  };

  load(location.hash.substr(1));

  animate();

}).call(this);
