// Generated by CoffeeScript 1.9.2
(function() {
  var SPHERE_COUNT, TIMESTEP, analyser, animate, audioContext, binCount, camera, createSphere, freqByteData, hemi, i, length, levelBins, levelHistory, levelsCount, levelsData, light, renderer, request, scene, source, spheres, timeByteData, updatePhysics, world;

  SPHERE_COUNT = 32;

  TIMESTEP = 1 / 60;

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100);

  camera.position.z = 50;

  scene.add(camera);

  light = new THREE.AmbientLight(0x404040);

  scene.add(light);

  hemi = new THREE.HemisphereLight(0xFF8585, 0x000000, 0.5);

  scene.add(hemi);

  renderer = new THREE.WebGLRenderer();

  renderer.setSize(window.innerWidth, window.innerHeight);

  renderer.setClearColor(0x333333);

  document.body.appendChild(renderer.domElement);

  world = new CANNON.World();

  world.gravity.set(0, 0, 0);

  world.broadphase = new CANNON.NaiveBroadphase();

  world.solver.iterations = 10;

  createSphere = function(x, y, z, i) {
    var body, geometry, material, mesh, phase, shape, variance;
    shape = new CANNON.Sphere(0.7);
    body = new CANNON.Body({
      mass: 1
    });
    body.position.set(x, y, z);
    body.velocity.set(Math.random() * 5, Math.random() * 5, z);
    body.addShape(shape);
    world.addBody(body);
    phase = Math.random() * Math.PI;
    variance = Math.random() * 0.3;
    body.preStep = function() {
      var distance, origin;
      origin = new CANNON.Vec3(x, y, z);
      origin.vsub(this.position, origin);
      distance = origin.norm();
      origin.normalize();
      origin.mult(40 * distance, this.force);
      shape.radius = 0.3 + Math.pow(levelsData[i], 1.2) * 5;
      shape.updateBoundingSphereRadius();
      body.updateBoundingRadius();
      material.color = new THREE.Color(0xE7112B);
      material.color.multiply(new THREE.Color(Math.min(0xffffff, 0xffffff * (levelsData[i] + 0.3))));
      material.specular = new THREE.Color(0xFF8585);
      material.specular.multiply(new THREE.Color(Math.min(0xffffff, 0xffffff * (levelsData[i] + 0.3))));
      return mesh.scale.set(shape.radius, shape.radius, shape.radius);
    };
    geometry = new THREE.SphereGeometry(1, 32, 32);
    material = new THREE.MeshPhongMaterial({
      color: 0xE7112B,
      specular: 0xFF8585,
      shininess: 50,
      shading: THREE.SmoothShading
    });
    mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    return [mesh, body];
  };

  spheres = (function() {
    var k, ref, results;
    results = [];
    for (i = k = 0, ref = SPHERE_COUNT; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      results.push(createSphere((i * 2 - SPHERE_COUNT) * 0.7, Math.random() * 0.01, Math.random(), i));
    }
    return results;
  })();

  animate = function() {
    requestAnimationFrame(animate);
    updatePhysics();
    return renderer.render(scene, camera);
  };

  updatePhysics = function() {
    var body, j, k, l, len, m, mesh, ref, ref1, ref2, results, sum;
    analyser.getByteFrequencyData(freqByteData);
    analyser.getByteTimeDomainData(timeByteData);
    for (i = k = 0, ref = levelsCount; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      sum = 0;
      for (j = l = 0, ref1 = levelBins; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
        sum += freqByteData[(i * levelBins) + j];
      }
      levelsData[i] = sum / levelBins / 256;
      levelsData[i] *= 1 + Math.pow((i / levelsCount) * 2, 2);
    }
    world.step(TIMESTEP);
    results = [];
    for (m = 0, len = spheres.length; m < len; m++) {
      ref2 = spheres[m], mesh = ref2[0], body = ref2[1];
      mesh.position.copy(body.position);
      results.push(mesh.quaternion.copy(body.quaternion));
    }
    return results;
  };

  levelsCount = SPHERE_COUNT;

  audioContext = new window.AudioContext();

  analyser = audioContext.createAnalyser();

  analyser.smoothingTimeConstant = 0.8;

  analyser.fftSize = 1024;

  analyser.connect(audioContext.destination);

  binCount = analyser.frequencyBinCount;

  levelsData = [];

  levelBins = Math.floor(binCount / levelsCount);

  freqByteData = new Uint8Array(binCount);

  timeByteData = new Uint8Array(binCount);

  length = 256;

  levelHistory = (function() {
    var k, results;
    results = [];
    for (i = k = 0; k < 256; i = ++k) {
      results.push(0);
    }
    return results;
  })();

  source = audioContext.createBufferSource();

  source.connect(analyser);

  request = new XMLHttpRequest();

  request.open("GET", "sample2.mp3", true);

  request.responseType = "arraybuffer";

  request.onload = function() {
    return audioContext.decodeAudioData(request.response, function(buffer) {
      var audioBuffer;
      audioBuffer = buffer;
      source.buffer = audioBuffer;
      source.loop = true;
      return source.start(0.0);
    }, function(e) {
      return console.log(e);
    });
  };

  request.send();

  animate();

}).call(this);
